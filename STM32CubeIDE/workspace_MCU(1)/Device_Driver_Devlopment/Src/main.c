/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <GPIO_devicedriver.h>

//#include <STM32F401RE.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * Rs - PC10, En - PC12, DB0 - PC14 err
 * DB1 - PC15 err, DB2 - PC2, DB3 - PC3
 * DB4 - PA5, DB5 - PA6, DB6 - PB12
 * DB7 - PA3 err, EXTI - PC13
 */
#define SYSCONFIG_ENR (0x40023800 + 0x44)
#define INTERRUPT_BASE_EXTI 0x40013C00U
#define Sys_Config_Base 0x40013800U
void data(uint8_t var);
void cmd(uint8_t var);
void write(uint8_t);

int main(void)
{
    /* Initialize GPIO ports */
    GPIO_init(portA);
    GPIO_init(portB);
    GPIO_init(portC);

    /* Control pins */
    GPIO_config_pin(10, GPIO_C, high_speed, Output, push_pull, No_pupd); // RS
    GPIO_config_pin(12, GPIO_C, high_speed, Output, push_pull, No_pupd); // EN

    /* Data pins */
    GPIO_config_pin(11, GPIO_C, high_speed, Output, push_pull, No_pupd); // DB0
    GPIO_config_pin(0, GPIO_C, high_speed, Output, push_pull, No_pupd); // DB1
    GPIO_config_pin(2,  GPIO_C, high_speed, Output, push_pull, No_pupd); // DB2
    GPIO_config_pin(3,  GPIO_C, high_speed, Output, push_pull, No_pupd); // DB3
    GPIO_config_pin(5,  GPIO_A, high_speed, Output, push_pull, No_pupd); // DB4
    GPIO_config_pin(6,  GPIO_A, high_speed, Output, push_pull, No_pupd); // DB5
    GPIO_config_pin(12, GPIO_B, high_speed, Output, push_pull, No_pupd); // DB6
    GPIO_config_pin(1,  GPIO_C, high_speed, Output, push_pull, No_pupd); // DB7

    GPIO_config_pin(13, GPIO_C, high_speed, Input, push_pull, No_pupd); //EXTI
    uint32_t *RCC_APB2ENR = (uint32_t*)(SYSCONFIG_ENR);
    *RCC_APB2ENR |= (1 << 14);
    uint32_t *EXTI_sysconfig4 = (uint32_t*)(Sys_Config_Base + 0x14);
    *EXTI_sysconfig4 |= (2 << 4);
    uint32_t *IMR = (uint32_t*)INTERRUPT_BASE_EXTI;
    *IMR |= (1 << 13);
    uint32_t *Rising_edge = (uint32_t*)(INTERRUPT_BASE_EXTI + 0x08);
    *Rising_edge |= (1 << 13);
    uint32_t *NVIC_Enable = (uint32_t*)(0xE000E100 + 0x04);
    *NVIC_Enable |= (1 << 8);
    //GPIO_alternate_func(GPIO_C, 8, )

    /* Small power-on delay */
    for(volatile int i = 0; i < 50000; i++);

    /* LCD Init sequence for 8-bit mode */
    cmd(0x38);   // Function set: 8-bit, 2 line, 5x7
    for(volatile int i = 0; i < 50000; i++);

    cmd(0x0C);   // Display ON, Cursor OFF
    for(volatile int i = 0; i < 50000; i++);

    cmd(0x06);   // Entry mode: Increment cursor
    for(volatile int i = 0; i < 50000; i++);

    cmd(0x01);   // Clear display
    for(volatile int i = 0; i < 200000; i++); // >1.5ms delay

    /* Print name */
    while(1)
    {
        char *name = "Jayant";
        while (*name) {
            data(*name++);
            for(volatile int i = 0; i < 50000; i++); // ~40us delay
        }
        for(volatile int i = 0; i < 1000000; i++); // pause before repeating
    }
}
void EXTI15_10_IRQHandler(void)
{
	cmd(0x01);
	for(int i = 0; i < 45; i++)
	{
		  char *name = "INTERRUPT";
		        while (*name) {
		            data(*name++);
		            for(volatile int i = 0; i < 50000; i++); // ~40us delay
		        }
		        for(volatile int i = 0; i < 1000000; i++); // pause before repeating
	}
}
/* Send 8-bit data to LCD */
void write(uint8_t var)
{
     GPIO_output_pin(11, GPIO_C, (var >> 0) & 1);  // DB0
     GPIO_output_pin(0, GPIO_C, (var >> 1) & 1);  // DB1
     GPIO_output_pin(2,  GPIO_C, (var >> 2) & 1);  // DB2
     GPIO_output_pin(3,  GPIO_C, (var >> 3) & 1);  // DB3
     GPIO_output_pin(5,  GPIO_A, (var >> 4) & 1);  // DB4
     GPIO_output_pin(6,  GPIO_A, (var >> 5) & 1);  // DB5
     GPIO_output_pin(12, GPIO_B, (var >> 6) & 1);  // DB6
     GPIO_output_pin(1,  GPIO_C, (var >> 7) & 1);  // DB7
}

/* Write data (characters) */
void data(uint8_t var)
{
    GPIO_output_pin(10, GPIO_C, 1);  // RS = 1
    write(var);

    GPIO_output_pin(12, GPIO_C, 1);  // EN = 1
    for(volatile int i = 0; i < 1000; i++);
    GPIO_output_pin(12, GPIO_C, 0);  // EN = 0

    for(volatile int i = 0; i < 50000; i++); // wait ~40us
}

/* Write command */
void cmd(uint8_t var)
{
    GPIO_output_pin(10, GPIO_C, 0);  // RS = 0
    write(var);

    GPIO_output_pin(12, GPIO_C, 1);  // EN = 1
    for(volatile int i = 0; i < 1000; i++);
    GPIO_output_pin(12, GPIO_C, 0);  // EN = 0

    for(volatile int i = 0; i < 50000; i++); // wait ~40us
}
